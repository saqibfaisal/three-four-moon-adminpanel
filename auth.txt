import express from "express"
import bcrypt  from "bcryptjs"
import  jwt  from "jsonwebtoken"
import { body, validationResult } from "express-validator"
import db from "../config/database.js"
import {authenticate as auth} from "../middleware/auth.js"

const router = express.Router()

// Register
router.post(
  "/register",
  [
    body("first_name").trim().isLength({ min: 2 }).withMessage("First name must be at least 2 characters"),
    body("last_name").trim().isLength({ min: 2 }).withMessage("Last name must be at least 2 characters"),
    body("email").isEmail().normalizeEmail().withMessage("Please provide a valid email"),
    body("password")
      .isLength({ min: 8 })
      .withMessage("Password must be at least 8 characters")
      .matches(/(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/)
      .withMessage("Password must contain at least one uppercase letter, one lowercase letter, and one number"),
    body("phone").optional().isMobilePhone().withMessage("Please provide a valid phone number"),
  ],
  async (req, res) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          message: "Validation failed",
          errors: errors.array(),
        })
      }

      const { first_name, last_name, email, password, phone } = req.body

      // Check if user already exists
      const existingUser = await db.query("SELECT id FROM users WHERE email = ?", [email])

      if (existingUser.length > 0) {
          if(existingUser[0].length){
              
        return res.status(400).json({
          message: "User with this email already exists",
          existingUser:existingUser[0]
        })
          }
      }

      // Hash password
      const saltRounds = 12
      const hashedPassword = await bcrypt.hash(password, saltRounds)

      // Create user
      const result = await db.query(
        `INSERT INTO users (first_name, last_name, email, password, phone, is_verified,role, created_at, updated_at) 
       VALUES (?, ?, ?, ?, ?, 1,'customer', NOW(), NOW())`,
        [first_name, last_name, email, hashedPassword, phone || null],
      )

      const userId = result.insertId

      // Get created user
      const [user] = await db.query(
        "SELECT id, first_name, last_name, email, phone, role, created_at, updated_at FROM users WHERE id = ?",
        [userId],
      )

      // Generate JWT token
      const token = jwt.sign({ userId: user.id, email: user.email, role: user.role }, process.env.JWT_SECRET, {
        expiresIn: "7d",
      })

      res.status(201).json({
        message: "User registered successfully",
        user,
        token,
      })
    } catch (error) {
      console.error("Registration error:", error)
      res.status(500).json({
        message: "Internal server error during registration",
      })
    }
  },
)

// Login
router.post(
  "/login",
  [
    body("email").isEmail().normalizeEmail().withMessage("Please provide a valid email"),
    body("password").notEmpty().withMessage("Password is required"),
  ],
  async (req, res) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          message: "Validation failed",
          errors: errors.array(),
        })
      }

      const { email, password } = req.body

      // Find user
      const users = await db.query(
        "SELECT id, first_name, last_name, email, password, phone, role, created_at, updated_at FROM users WHERE email = ?",
        [email],
      )

      if (users.length === 0) {
        return res.status(401).json({
          message: "Invalid email or password",
        })
      }

      const user = users[0][0]
      console.log("User found:", users,password)
      // Check password
      const isPasswordValid = await bcrypt.compare(password, user.password)
      if (!isPasswordValid) {
        return res.status(401).json({
          message: "Invalid email or password",
        })
      }

      // Remove password from user object
      delete user.password

      // Generate JWT token
      const token = jwt.sign({ userId: user.id, email: user.email, role: user.role }, process.env.JWT_SECRET, {
        expiresIn: "7d",
      })

      // Update last login
      await db.query("UPDATE users SET updated_at = NOW() WHERE id = ?", [user.id])

      res.json({
        message: "Login successful",
        user,
        token,
      })
    } catch (error) {
      console.error("Login error:", error)
      res.status(500).json({
        message: "Internal server error during login",
      })
    }
  },
)

// Get current user
router.get("/me", auth, async (req, res) => {
  try {
    const users = await db.query(
      "SELECT id, first_name, last_name, email, phone, role, created_at, updated_at FROM users WHERE id = ?",
      [req.user.userId],
    )

    if (users.length === 0) {
      return res.status(404).json({
        message: "User not found",
      })
    }

    res.json({
      user: users[0],
    })
  } catch (error) {
    console.error("Get user error:", error)
    res.status(500).json({
      message: "Internal server error",
    })
  }
})

// Logout
router.post("/logout", auth, async (req, res) => {
  try {
    // In a more sophisticated setup, you might want to blacklist the token
    // For now, we'll just return success and let the client handle token removal
    res.json({
      message: "Logged out successfully",
    })
  } catch (error) {
    console.error("Logout error:", error)
    res.status(500).json({
      message: "Internal server error during logout",
    })
  }
})

// Forgot password
router.post(
  "/forgot-password",
  [body("email").isEmail().normalizeEmail().withMessage("Please provide a valid email")],
  async (req, res) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          message: "Validation failed",
          errors: errors.array(),
        })
      }

      const { email } = req.body

      // Check if user exists
      const users = await db.query("SELECT id FROM users WHERE email = ?", [email])

      // Always return success to prevent email enumeration
      if (users.length === 0) {
        return res.json({
          message: "If an account with that email exists, we have sent a password reset link",
        })
      }

      // Generate reset token
      const resetToken = jwt.sign({ userId: users[0].id, type: "password_reset" }, process.env.JWT_SECRET, {
        expiresIn: "1h",
      })

      // In a real application, you would send an email here
      // For now, we'll just log the token (remove this in production)
      console.log(`Password reset token for ${email}: ${resetToken}`)

      res.json({
        message: "If an account with that email exists, we have sent a password reset link",
      })
    } catch (error) {
      console.error("Forgot password error:", error)
      res.status(500).json({
        message: "Internal server error",
      })
    }
  },
)

// Reset password
router.post(
  "/reset-password",
  [
    body("token").notEmpty().withMessage("Reset token is required"),
    body("password")
      .isLength({ min: 8 })
      .withMessage("Password must be at least 8 characters")
      .matches(/(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/)
      .withMessage("Password must contain at least one uppercase letter, one lowercase letter, and one number"),
  ],
  async (req, res) => {
    try {
      const errors = validationResult(req)
      if (!errors.isEmpty()) {
        return res.status(400).json({
          message: "Validation failed",
          errors: errors.array(),
        })
      }

      const { token, password } = req.body

      // Verify reset token
      let decoded
      try {
        decoded = jwt.verify(token, process.env.JWT_SECRET)
        if (decoded.type !== "password_reset") {
          throw new Error("Invalid token type")
        }
      } catch (error) {
        return res.status(400).json({
          message: "Invalid or expired reset token",
        })
      }

      // Hash new password
      const saltRounds = 12
      const hashedPassword = await bcrypt.hash(password, saltRounds)

      // Update password
      await db.query("UPDATE users SET password = ?, updated_at = NOW() WHERE id = ?", [hashedPassword, decoded.userId])

      res.json({
        message: "Password reset successfully",
      })
    } catch (error) {
      console.error("Reset password error:", error)
      res.status(500).json({
        message: "Internal server error",
      })
    }
  },
)

export default router
